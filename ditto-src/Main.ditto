module Main exports (
    main,
)

import (js-task) Task

import (std) Maybe (
    Maybe(..),
)
import (std) Never (
    Never,
)
import (std) Result (
    Result(..),
)

import (vdom) App
import (vdom) Attributes as Attr
import (vdom) Element (
    Element,
)
import (vdom) Events
import (vdom) Html

import Compiler (
    Compiler,
)
import Editor (
    Editor,
)


main = fn (container: Element): Effect(Unit) -> App.mount(
    {
        container = container,
        init = fn () -> {state = initial_state, task = Just(init_compiler) },
        view = view,
        update = update,
    },
)

type alias State = { compiler: CompilerState, editor: EditorState }

type CompilerState =
    | CompilerLoading
    | CompilerLoaded(Compiler)

type EditorState =
    | EditorLoading
    | EditorLoaded(Editor)

initial_state: State = { editor = EditorLoading, compiler = CompilerLoading }

type alias Html = Html.Html(Event)

view = fn (_state: State): Array(Html) -> [
    Html.div(
        [
            Attr.id("editor"),
            Events.on_mount(EditorMounted),
            Events.on_unmount(EditorUnmounted),
        ],
        [],
    ),
    Html.button([Events.on_click(FormatCode)], [Html.text("format")]),
]

type Event =
    | NoOp
    | EditorMounted(Element)
    | EditorInitialized(Editor)
    | EditorUnmounted
    | CompilerInitialized(Compiler)
    | FormatCode

type alias Next = App.Next(State, Event)

update = fn (state: State, event: Event): Next ->
    match event with
    | NoOp -> { state = state, task = Nothing }
    | EditorMounted(element) -> {
        state = state,
        task = Just(init_editor(element)),
    }
    | EditorInitialized(editor) -> {
        state = {
            state |editor = EditorLoaded(editor)},
        task = Nothing,
    }
    | EditorUnmounted -> {
        state = state,
        task = match state.editor with
        | EditorLoaded(editor) -> Just(unmount_editor(editor))
        | _ -> Nothing
        end,
    }
    | CompilerInitialized(compiler) -> {
        state = {
            state |compiler = CompilerLoaded(compiler)},
        task = Nothing,
    }
    | FormatCode ->
        match state.editor with
        | EditorLoaded(editor) ->
            match state.compiler with
            | CompilerLoaded(compiler) -> {
                state = state,
                task = Just(format_code(editor, compiler)),
            }
            | _ -> { state = state, task = Nothing }
            end
        | _ -> { state = state, task = Nothing }
        end
    end

type alias Task = Task.Task(Event, Never)

init_editor = fn (element: Element): Task ->
    Task.from_effect(Editor.init(default_code, element))
    |> Task.map_result(
        fn (result) ->
            match result with
            | Ok(editor) -> Ok(EditorInitialized(editor))
            | Err(_) -> Ok(NoOp)
            end,
    )

unmount_editor = fn (editor: Editor): Task ->
    Task.from_effect(Editor.destroy(editor))
    |> Task.map_result(fn (_) -> Ok(NoOp))

init_compiler: Task =
    Compiler.init
    |> Task.map_result(
        fn (result) ->
            match result with
            | Ok(compiler) -> Ok(CompilerInitialized(compiler))
            | Err(_) -> Ok(NoOp)
            end,
    )

format_code = fn (editor: Editor, compiler: Compiler): Task ->
    Task.from_effect(Editor.get_text(editor))
    |> Task.and_then(
        fn (code) ->
            match compiler.fmt(code) with
            | Ok(formatted) -> Task.succeed(formatted)
            | Err(_error) -> Task.succeed(code)
            end,
    )
    |> Task.and_then(
        fn (formatted) -> Task.from_effect(Editor.set_text(editor, formatted)),
    )
    |> Task.map_result(fn (_) -> Ok(NoOp))

default_code = "module Maybe exports (..)

type Maybe(a) = Just(a) | Nothing

"
